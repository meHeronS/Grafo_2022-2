\documentclass[12pt, a4paper]{article}

% Pacotes essenciais para codificação e idioma
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}

% Pacotes para layout e formatação
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{indentfirst}
\usepackage{hyperref}

% Pacotes para exibição de código fonte
\usepackage{listings}
\usepackage{xcolor}

% Configuração das margens (Padrão ABNT)
\geometry{a4paper, left=3cm, top=3cm, right=2cm, bottom=2cm}

% Definição de cores para o código (Estilo Visual Studio)
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Configuração do estilo de listagem para C#
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=[Sharp]C
}

\lstset{style=mystyle}

% Informações do Documento
\title{\textbf{Relatório do Trabalho de Grafos}}
\author{Heron V. V. Silva}
\date{Novembro de 2022 (Refatorado em Dezembro de 2025)}

\begin{document}

\maketitle

\begin{abstract}
Este documento apresenta a implementação e a refatoração de um sistema de gerenciamento de grafos em C\#. O objetivo é demonstrar a aplicação de algoritmos clássicos de teoria dos grafos, como Dijkstra, Coloração de Welsh-Powell e Detecção de Ciclos (Tarjan), utilizando boas práticas de programação e arquitetura de software moderna.
\end{abstract}

\tableofcontents
\newpage

\section{Introdução}
O projeto "Gerenciador de Grafos" foi desenvolvido originalmente em 2022 como parte da disciplina de Algoritmos em Grafos. Em 2025, o projeto passou por uma refatoração completa para modernizar a base de código, corrigir bugs lógicos e melhorar a performance utilizando estruturas de dados otimizadas (como Dictionaries em vez de Listas lineares).

\section{Estrutura do Projeto}
A solução foi reestruturada para seguir o Princípio da Responsabilidade Única (SRP), separando a lógica do grafo, os algoritmos e a interface do usuário.

\begin{itemize}
    \item \textbf{Grafo.cs}: Contém a estrutura de dados principal (\textit{Graph}, \textit{Vertex}, \textit{Edge}).
    \item \textbf{Algoritmo\_D.cs}: Implementação do algoritmo de Dijkstra para caminhos mínimos.
    \item \textbf{Colorir\_Grafo.cs}: Implementação de coloração de grafos (Heurística Gulosa).
    \item \textbf{Cycle.cs}: Algoritmos para detecção de ciclos (Tarjan e Naive).
    \item \textbf{Save.cs}: Módulo de persistência para exportação em CSV.
    \item \textbf{Programa.cs}: Ponto de entrada e menu interativo do sistema.
\end{itemize}

\section{Implementação dos Algoritmos}

A seguir, apresentamos o código fonte refatorado das principais classes do sistema.

\subsection{Classe Principal: Grafo.cs}
Esta classe gerencia os vértices e arestas, oferecendo métodos de complexidade O(1) para buscas.
\lstinputlisting{Grafo.cs}

\subsection{Algoritmo de Dijkstra: Algoritmo\_D.cs}
Implementação corrigida para acumular custos de caminho corretamente.
\lstinputlisting{Algoritmo_D.cs}

\subsection{Coloração de Grafos: Colorir\_Grafo.cs}
Utiliza a heurística de ordenação por grau para otimizar o uso de cores.
\lstinputlisting{Colorir_Grafo.cs}

\subsection{Detecção de Ciclos: Cycle.cs}
Comparação entre o método de Tarjan (SCCs) e uma busca em profundidade simples (Naive).
\lstinputlisting{Cycle.cs}

\subsection{Persistência de Dados: Save.cs}
Classe responsável por salvar o estado atual do grafo em arquivo CSV.
\lstinputlisting{Save.cs}

\subsection{Interface do Usuário: Programa.cs}
Menu principal que integra todas as funcionalidades.
\lstinputlisting{Programa.cs}

\section{Conclusão}
A refatoração do projeto permitiu não apenas corrigir falhas da implementação original, mas também elevar a qualidade do código para padrões profissionais. A utilização de ferramentas de versionamento e a reestruturação orientada a objetos garantem que o sistema seja extensível e de fácil manutenção.

\end{document}
